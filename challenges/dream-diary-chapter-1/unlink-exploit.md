# Unlink Exploit

## Summary

In this approach, we overwrite `PREV_SIZE` to shrink the size of the previous chunk. This tricks the heap into thinking that the previous chunk's metadata starts _where our data does_, enabling us to control chunk metadata. As we can control the `fd` and `bk` pointers, we can execute an [**unlink exploit**](https://ir0nstone.gitbook.io/notes/types/heap/unlink-exploit). We can bypass the [unlink security checks ](https://ir0nstone.gitbook.io/notes/types/heap/unlink-exploit#protections)by pointing `fd` and `bk` to the chunklist, which contains a pointer to the chunk.

This enables us to overwrite a chunklist entry with the address of the chunklist itself, meaning we can now edit the chunklist. This gives us the ability to write to wherever we want, and we choose to target the GOT. We can overwrite `strlen@got` with `puts@plt` as that makes it functionally equivalent and then read a libc address. From here we overwrite `free@got` with the address of system and `free()` a chunk containing `/bin/sh`.

## Exploitation

### The Unlink

To bypass the unlink check, we need `P->fd->bk` to point to the address of `P`, meaning `P->fd` has to point `0x18` bytes behind it. Because we want `P->fd` to be within the chunklist \(most simply at the beginning\), we will allocate 3 chunks before the chunk we use for the `unlink()` exploit. Each chunk we allocate takes up `0x8` bytes of space on the chunklist \(this will make more sense later, I promise\).

We'll choose a size of `0x118` for the chunks. Firstly, this means the chunk does not fall in **fastbin range**. Secondly, the additional `0x8` bytes means we do in fact overwrite `prev_size`. Other sizes such as `0x108` would also work, but make sure Chunk 4 overwrites Chunk 5's `prev_size` field.

![PREV\_SIZE is overwritten](../../.gitbook/assets/image%20%2813%29.png)



